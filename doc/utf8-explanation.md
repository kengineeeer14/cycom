# UTF-8エンコーディングの仕組み

## UTF-8とは？

UTF-8は、世界中のあらゆる文字を表現できる文字エンコーディング方式です。1文字を1〜4バイトで表現します。

## コードポイント（Code Point）とは？

**コードポイント**は、Unicodeで定義された各文字に割り当てられた**一意の番号**です。

### 具体例

| 文字 | コードポイント | 16進数表記 | 10進数 |
|-----|--------------|-----------|-------|
| 'A' | U+0041 | 0x41 | 65 |
| 'あ' | U+3042 | 0x3042 | 12354 |
| '🚴' | U+1F6B4 | 0x1F6B4 | 128692 |

### コードポイントとUTF-8の関係

- **コードポイント**：文字の抽象的な番号（文字のID）
- **UTF-8**：そのコードポイントをバイト列として表現する方法

```
文字 'あ' の場合:

コードポイント: U+3042 (12354)
      ↓ UTF-8エンコード
バイト列: 0xE3 0x81 0x82 (3バイト)
```

### 簡単な比喩

- **コードポイント** = 住所番号（例：「東京都千代田区1-1-1」）
- **UTF-8** = その住所を書く方法（例：郵便番号や地図上の座標）

同じ住所（コードポイント）でも、表現方法（エンコーディング）は複数あります：
- UTF-8：可変長（1〜4バイト）
- UTF-16：2または4バイト
- UTF-32：常に4バイト

### Unicodeの範囲

Unicodeは約114万個のコードポイントを定義できます：
- **U+0000 〜 U+10FFFF**（0 〜 1,114,111）

現在約15万文字が割り当てられており、絵文字や古代文字なども含まれます。

## UTF-8の基本ルール

### 1バイト文字（ASCII）
```
0xxxxxxx
```
- 先頭ビットが`0`
- 範囲: 0x00〜0x7F（0〜127）
- 例: 'A' = 0x41 = 01000001

### 2バイト文字
```
110xxxxx 10xxxxxx
```
- 1バイト目: `110`で始まる（上位5ビットが有効データ）
- 2バイト目: `10`で始まる（上位6ビットが有効データ）
- 範囲: U+0080〜U+07FF
- 例: 'α' (U+03B1)

### 3バイト文字
```
1110xxxx 10xxxxxx 10xxxxxx
```
- 1バイト目: `1110`で始まる（上位4ビットが有効データ）
- 2〜3バイト目: `10`で始まる（各6ビットが有効データ）
- 範囲: U+0800〜U+FFFF
- 例: 'あ' (U+3042)、漢字、多くの記号

### 4バイト文字
```
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```
- 1バイト目: `11110`で始まる（上位3ビットが有効データ）
- 2〜4バイト目: `10`で始まる（各6ビットが有効データ）
- 範囲: U+10000〜U+10FFFF
- 例: 絵文字 '🚴' (U+1F6B4)

## 実際の例で理解する

### 例1: ASCII文字 'H' (U+0048)

```
バイト列: 0x48
2進数:    01001000
```

- 先頭ビットが`0`なので1バイト文字
- そのままの値がコードポイント: 0x48

### 例2: ギリシャ文字 'α' (U+03B1)

```
バイト列: 0xCE 0xB1
2進数:    11001110 10110001
```

**デコード手順:**

1. **1バイト目 (0xCE = 11001110)**
   - `110`で始まる → 2バイト文字
   - 有効データは下位5ビット: `01110` = 0x0E

2. **2バイト目 (0xB1 = 10110001)**
   - `10`で始まる → 継続バイト
   - 有効データは下位6ビット: `110001` = 0x31

3. **結合**
   ```
   コードポイント = (0x0E << 6) | 0x31
                  = (14 << 6) | 49
                  = 896 + 49
                  = 945
                  = 0x03B1 ✓
   ```

### 例3: 日本語 'あ' (U+3042)

```
バイト列: 0xE3 0x81 0x82
2進数:    11100011 10000001 10000010
```

**デコード手順:**

1. **1バイト目 (0xE3 = 11100011)**
   - `1110`で始まる → 3バイト文字
   - 有効データは下位4ビット: `0011` = 0x03

2. **2バイト目 (0x81 = 10000001)**
   - 有効データ: `000001` = 0x01

3. **3バイト目 (0x82 = 10000010)**
   - 有効データ: `000010` = 0x02

4. **結合**
   ```
   コードポイント = (0x03 << 12) | (0x01 << 6) | 0x02
                  = (3 << 12) | (1 << 6) | 2
                  = 12288 + 64 + 2
                  = 12354
                  = 0x3042 ✓
   ```

### 例4: 絵文字 '🚴' (U+1F6B4)

```
バイト列: 0xF0 0x9F 0x9A 0xB4
2進数:    11110000 10011111 10011010 10110100
```

**デコード手順:**

1. **1バイト目 (0xF0 = 11110000)**
   - `11110`で始まる → 4バイト文字
   - 有効データ: `000` = 0x00

2. **2バイト目 (0x9F = 10011111)**
   - 有効データ: `011111` = 0x1F

3. **3バイト目 (0x9A = 10011010)**
   - 有効データ: `011010` = 0x1A

4. **4バイト目 (0xB4 = 10110100)**
   - 有効データ: `110100` = 0x34

5. **結合**
   ```
   コードポイント = (0x00 << 18) | (0x1F << 12) | (0x1A << 6) | 0x34
                  = 0 | 126976 | 1664 | 52
                  = 128692
                  = 0x1F6B4 ✓
   ```

## NextCodepoint関数の動作

この関数は、**UTF-8バイト列からコードポイントを抽出**します。

### 処理の流れ

```
入力: UTF-8バイト列 "Aあ"
      ↓
Step 1: 'A' → 0x41 (1バイト)
        → コードポイント: U+0041
      ↓
Step 2: 'あ' → 0xE3 0x81 0x82 (3バイト)
        → コードポイント: U+3042
      ↓
出力: [U+0041, U+3042]
```

### ステップ1: 1バイト目を判定

```cpp
const unsigned char first_byte = utf8_str[index++];
```

1バイト目のビットパターンで文字の長さを判定:

| ビットパターン | 文字の種類 | 判定方法 |
|---------------|-----------|---------|
| `0xxxxxxx` | 1バイト | `first_byte < 0x80` |
| `110xxxxx` | 2バイト | `(first_byte >> 5) == 0x6` |
| `1110xxxx` | 3バイト | `(first_byte >> 4) == 0xE` |
| `11110xxx` | 4バイト | `(first_byte >> 3) == 0x1E` |

### ステップ2: 必要なバイト数を読み込む

境界チェックを行い、必要なバイト数が残っているか確認します:

- 2バイト文字: あと1バイト必要
- 3バイト文字: あと2バイト必要
- 4バイト文字: あと3バイト必要

### ステップ3: ビットマスクと結合

各バイトから有効データを抽出し、シフトして結合します。

**2バイト文字の例:**
```cpp
// 1バイト目の下位5ビットを抽出して6ビット左シフト
(first_byte & 0x1F) << 6

// 2バイト目の下位6ビットを抽出
second_byte & 0x3F

// OR演算で結合
codepoint = ((first_byte & 0x1F) << 6) | (second_byte & 0x3F)
```

**3バイト文字の例:**
```cpp
codepoint = ((first_byte & 0x0F) << 12) |    // 1バイト目の下位4ビット
            ((second_byte & 0x3F) << 6) |     // 2バイト目の下位6ビット
            (third_byte & 0x3F)               // 3バイト目の下位6ビット
```

## まとめ

UTF-8は可変長エンコーディングで、1〜4バイトで文字を表現します:

1. **1バイト目のパターン**で文字の長さを判定
2. **必要な数のバイト**を読み込む
3. **ビットマスク**で有効データを抽出
4. **シフトとOR演算**でコードポイントを構築

この仕組みにより、ASCII互換性を保ちながら、世界中のあらゆる文字を効率的に表現できます。
